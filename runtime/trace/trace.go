// Code generated by a tool. DO NOT EDIT.

// Package trace provides a mockable wrapper for runtime/trace.
package trace

import (
	context "context"
	io "io"
	trace "runtime/trace"
)

var _ Interface = &Impl{}
var _ = trace.IsEnabled

type Interface interface {
	IsEnabled() bool
	Log(ctx context.Context, category string, message string)
	Logf(ctx context.Context, category string, format string, args ...any)
	NewTask(pctx context.Context, taskType string) (ctx context.Context, task *trace.Task)
	Start(w io.Writer) error
	StartRegion(ctx context.Context, regionType string) *trace.Region
	Stop()
	WithRegion(ctx context.Context, regionType string, fn func())
}

type Impl struct{}

func (*Impl) IsEnabled() bool {
	return trace.IsEnabled()
}
func (*Impl) Log(ctx context.Context, category string, message string) {
	trace.Log(ctx, category, message)
}
func (*Impl) Logf(ctx context.Context, category string, format string, args ...any) {
	trace.Logf(ctx, category, format, args...)
}
func (*Impl) NewTask(pctx context.Context, taskType string) (ctx context.Context, task *trace.Task) {
	return trace.NewTask(pctx, taskType)
}
func (*Impl) Start(w io.Writer) error {
	return trace.Start(w)
}
func (*Impl) StartRegion(ctx context.Context, regionType string) *trace.Region {
	return trace.StartRegion(ctx, regionType)
}
func (*Impl) Stop() {
	trace.Stop()
}
func (*Impl) WithRegion(ctx context.Context, regionType string, fn func()) {
	trace.WithRegion(ctx, regionType, fn)
}
