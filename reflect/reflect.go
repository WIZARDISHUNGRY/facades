// Code generated by a tool. DO NOT EDIT.

// Package reflect provides a mockable wrapper for reflect.
package reflect

import (
	reflect "reflect"
	unsafe "unsafe"
)

var _ Interface = &Impl{}
var _ = reflect.Append

type Interface interface {
	Append(s reflect.Value, x ...reflect.Value) reflect.Value
	AppendSlice(s reflect.Value, t reflect.Value) reflect.Value
	ArrayOf(length int, elem reflect.Type) reflect.Type
	ChanOf(dir reflect.ChanDir, t reflect.Type) reflect.Type
	Copy(dst reflect.Value, src reflect.Value) int
	DeepEqual(x any, y any) bool
	FuncOf(in []reflect.Type, out []reflect.Type, variadic bool) reflect.Type
	Indirect(v reflect.Value) reflect.Value
	MakeChan(typ reflect.Type, buffer int) reflect.Value
	MakeFunc(typ reflect.Type, fn func(args []reflect.Value) (results []reflect.Value)) reflect.Value
	MakeMap(typ reflect.Type) reflect.Value
	MakeMapWithSize(typ reflect.Type, n int) reflect.Value
	MakeSlice(typ reflect.Type, len int, cap int) reflect.Value
	MapOf(key reflect.Type, elem reflect.Type) reflect.Type
	New(typ reflect.Type) reflect.Value
	NewAt(typ reflect.Type, p unsafe.Pointer) reflect.Value
	PointerTo(t reflect.Type) reflect.Type
	PtrTo(t reflect.Type) reflect.Type
	Select(cases []reflect.SelectCase) (chosen int, recv reflect.Value, recvOK bool)
	SliceOf(t reflect.Type) reflect.Type
	StructOf(fields []reflect.StructField) reflect.Type
	Swapper(slice any) func(i int, j int)
	TypeOf(i any) reflect.Type
	ValueOf(i any) reflect.Value
	VisibleFields(t reflect.Type) []reflect.StructField
	Zero(typ reflect.Type) reflect.Value
}

type Impl struct{}

func (*Impl) Append(s reflect.Value, x ...reflect.Value) reflect.Value {
	return reflect.Append(s, x...)
}
func (*Impl) AppendSlice(s reflect.Value, t reflect.Value) reflect.Value {
	return reflect.AppendSlice(s, t)
}
func (*Impl) ArrayOf(length int, elem reflect.Type) reflect.Type {
	return reflect.ArrayOf(length, elem)
}
func (*Impl) ChanOf(dir reflect.ChanDir, t reflect.Type) reflect.Type {
	return reflect.ChanOf(dir, t)
}
func (*Impl) Copy(dst reflect.Value, src reflect.Value) int {
	return reflect.Copy(dst, src)
}
func (*Impl) DeepEqual(x any, y any) bool {
	return reflect.DeepEqual(x, y)
}
func (*Impl) FuncOf(in []reflect.Type, out []reflect.Type, variadic bool) reflect.Type {
	return reflect.FuncOf(in, out, variadic)
}
func (*Impl) Indirect(v reflect.Value) reflect.Value {
	return reflect.Indirect(v)
}
func (*Impl) MakeChan(typ reflect.Type, buffer int) reflect.Value {
	return reflect.MakeChan(typ, buffer)
}
func (*Impl) MakeFunc(typ reflect.Type, fn func(args []reflect.Value) (results []reflect.Value)) reflect.Value {
	return reflect.MakeFunc(typ, fn)
}
func (*Impl) MakeMap(typ reflect.Type) reflect.Value {
	return reflect.MakeMap(typ)
}
func (*Impl) MakeMapWithSize(typ reflect.Type, n int) reflect.Value {
	return reflect.MakeMapWithSize(typ, n)
}
func (*Impl) MakeSlice(typ reflect.Type, len int, cap int) reflect.Value {
	return reflect.MakeSlice(typ, len, cap)
}
func (*Impl) MapOf(key reflect.Type, elem reflect.Type) reflect.Type {
	return reflect.MapOf(key, elem)
}
func (*Impl) New(typ reflect.Type) reflect.Value {
	return reflect.New(typ)
}
func (*Impl) NewAt(typ reflect.Type, p unsafe.Pointer) reflect.Value {
	return reflect.NewAt(typ, p)
}
func (*Impl) PointerTo(t reflect.Type) reflect.Type {
	return reflect.PointerTo(t)
}
func (*Impl) PtrTo(t reflect.Type) reflect.Type {
	return reflect.PtrTo(t)
}
func (*Impl) Select(cases []reflect.SelectCase) (chosen int, recv reflect.Value, recvOK bool) {
	return reflect.Select(cases)
}
func (*Impl) SliceOf(t reflect.Type) reflect.Type {
	return reflect.SliceOf(t)
}
func (*Impl) StructOf(fields []reflect.StructField) reflect.Type {
	return reflect.StructOf(fields)
}
func (*Impl) Swapper(slice any) func(i int, j int) {
	return reflect.Swapper(slice)
}
func (*Impl) TypeOf(i any) reflect.Type {
	return reflect.TypeOf(i)
}
func (*Impl) ValueOf(i any) reflect.Value {
	return reflect.ValueOf(i)
}
func (*Impl) VisibleFields(t reflect.Type) []reflect.StructField {
	return reflect.VisibleFields(t)
}
func (*Impl) Zero(typ reflect.Type) reflect.Value {
	return reflect.Zero(typ)
}
