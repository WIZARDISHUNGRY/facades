// Code generated by a tool. DO NOT EDIT.

// Package ecdsa provides a mockable wrapper for crypto/ecdsa.
package ecdsa

import (
	ecdsa "crypto/ecdsa"
	elliptic "crypto/elliptic"
	io "io"
	big "math/big"
)

var _ Interface = &Impl{}
var _ = ecdsa.GenerateKey

type Interface interface {
	GenerateKey(c elliptic.Curve, rand io.Reader) (*ecdsa.PrivateKey, error)
	Sign(rand io.Reader, priv *ecdsa.PrivateKey, hash []byte) (r *big.Int, s *big.Int, err error)
	SignASN1(rand io.Reader, priv *ecdsa.PrivateKey, hash []byte) ([]byte, error)
	Verify(pub *ecdsa.PublicKey, hash []byte, r *big.Int, s *big.Int) bool
	VerifyASN1(pub *ecdsa.PublicKey, hash []byte, sig []byte) bool
}

type Impl struct{}

func (*Impl) GenerateKey(c elliptic.Curve, rand io.Reader) (*ecdsa.PrivateKey, error) {
	return ecdsa.GenerateKey(c, rand)
}
func (*Impl) Sign(rand io.Reader, priv *ecdsa.PrivateKey, hash []byte) (r *big.Int, s *big.Int, err error) {
	return ecdsa.Sign(rand, priv, hash)
}
func (*Impl) SignASN1(rand io.Reader, priv *ecdsa.PrivateKey, hash []byte) ([]byte, error) {
	return ecdsa.SignASN1(rand, priv, hash)
}
func (*Impl) Verify(pub *ecdsa.PublicKey, hash []byte, r *big.Int, s *big.Int) bool {
	return ecdsa.Verify(pub, hash, r, s)
}
func (*Impl) VerifyASN1(pub *ecdsa.PublicKey, hash []byte, sig []byte) bool {
	return ecdsa.VerifyASN1(pub, hash, sig)
}
