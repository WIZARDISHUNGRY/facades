// Code generated by a tool. DO NOT EDIT.

// Package rsa provides a mockable wrapper for crypto/rsa.
package rsa

import (
	crypto "crypto"
	rsa "crypto/rsa"
	hash "hash"
	io "io"
)

var _ Interface = &Impl{}
var _ = rsa.DecryptOAEP

type Interface interface {
	DecryptOAEP(hash hash.Hash, random io.Reader, priv *rsa.PrivateKey, ciphertext []byte, label []byte) ([]byte, error)
	DecryptPKCS1v15(rand io.Reader, priv *rsa.PrivateKey, ciphertext []byte) ([]byte, error)
	DecryptPKCS1v15SessionKey(rand io.Reader, priv *rsa.PrivateKey, ciphertext []byte, key []byte) error
	EncryptOAEP(hash hash.Hash, random io.Reader, pub *rsa.PublicKey, msg []byte, label []byte) ([]byte, error)
	EncryptPKCS1v15(rand io.Reader, pub *rsa.PublicKey, msg []byte) ([]byte, error)
	GenerateKey(random io.Reader, bits int) (*rsa.PrivateKey, error)
	GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*rsa.PrivateKey, error)
	SignPKCS1v15(rand io.Reader, priv *rsa.PrivateKey, hash crypto.Hash, hashed []byte) ([]byte, error)
	SignPSS(rand io.Reader, priv *rsa.PrivateKey, hash crypto.Hash, digest []byte, opts *rsa.PSSOptions) ([]byte, error)
	VerifyPKCS1v15(pub *rsa.PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error
	VerifyPSS(pub *rsa.PublicKey, hash crypto.Hash, digest []byte, sig []byte, opts *rsa.PSSOptions) error
}

type Impl struct{}

func (*Impl) DecryptOAEP(hash hash.Hash, random io.Reader, priv *rsa.PrivateKey, ciphertext []byte, label []byte) ([]byte, error) {
	return rsa.DecryptOAEP(hash, random, priv, ciphertext, label)
}
func (*Impl) DecryptPKCS1v15(rand io.Reader, priv *rsa.PrivateKey, ciphertext []byte) ([]byte, error) {
	return rsa.DecryptPKCS1v15(rand, priv, ciphertext)
}
func (*Impl) DecryptPKCS1v15SessionKey(rand io.Reader, priv *rsa.PrivateKey, ciphertext []byte, key []byte) error {
	return rsa.DecryptPKCS1v15SessionKey(rand, priv, ciphertext, key)
}
func (*Impl) EncryptOAEP(hash hash.Hash, random io.Reader, pub *rsa.PublicKey, msg []byte, label []byte) ([]byte, error) {
	return rsa.EncryptOAEP(hash, random, pub, msg, label)
}
func (*Impl) EncryptPKCS1v15(rand io.Reader, pub *rsa.PublicKey, msg []byte) ([]byte, error) {
	return rsa.EncryptPKCS1v15(rand, pub, msg)
}
func (*Impl) GenerateKey(random io.Reader, bits int) (*rsa.PrivateKey, error) {
	return rsa.GenerateKey(random, bits)
}
func (*Impl) GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*rsa.PrivateKey, error) {
	return rsa.GenerateMultiPrimeKey(random, nprimes, bits)
}
func (*Impl) SignPKCS1v15(rand io.Reader, priv *rsa.PrivateKey, hash crypto.Hash, hashed []byte) ([]byte, error) {
	return rsa.SignPKCS1v15(rand, priv, hash, hashed)
}
func (*Impl) SignPSS(rand io.Reader, priv *rsa.PrivateKey, hash crypto.Hash, digest []byte, opts *rsa.PSSOptions) ([]byte, error) {
	return rsa.SignPSS(rand, priv, hash, digest, opts)
}
func (*Impl) VerifyPKCS1v15(pub *rsa.PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error {
	return rsa.VerifyPKCS1v15(pub, hash, hashed, sig)
}
func (*Impl) VerifyPSS(pub *rsa.PublicKey, hash crypto.Hash, digest []byte, sig []byte, opts *rsa.PSSOptions) error {
	return rsa.VerifyPSS(pub, hash, digest, sig, opts)
}
