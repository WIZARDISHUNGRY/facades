// Code generated by a tool. DO NOT EDIT.

// Package tls provides a mockable wrapper for crypto/tls.
package tls

import (
	tls "crypto/tls"
	net "net"
)

var _ Interface = &Impl{}
var _ = tls.CipherSuiteName

type Interface interface {
	CipherSuiteName(id uint16) string
	CipherSuites() []*tls.CipherSuite
	Client(conn net.Conn, config *tls.Config) *tls.Conn
	Dial(network string, addr string, config *tls.Config) (*tls.Conn, error)
	DialWithDialer(dialer *net.Dialer, network string, addr string, config *tls.Config) (*tls.Conn, error)
	InsecureCipherSuites() []*tls.CipherSuite
	Listen(network string, laddr string, config *tls.Config) (net.Listener, error)
	LoadX509KeyPair(certFile string, keyFile string) (tls.Certificate, error)
	NewLRUClientSessionCache(capacity int) tls.ClientSessionCache
	NewListener(inner net.Listener, config *tls.Config) net.Listener
	Server(conn net.Conn, config *tls.Config) *tls.Conn
	X509KeyPair(certPEMBlock []byte, keyPEMBlock []byte) (tls.Certificate, error)
}

type Impl struct{}

func (*Impl) CipherSuiteName(id uint16) string {
	return tls.CipherSuiteName(id)
}
func (*Impl) CipherSuites() []*tls.CipherSuite {
	return tls.CipherSuites()
}
func (*Impl) Client(conn net.Conn, config *tls.Config) *tls.Conn {
	return tls.Client(conn, config)
}
func (*Impl) Dial(network string, addr string, config *tls.Config) (*tls.Conn, error) {
	return tls.Dial(network, addr, config)
}
func (*Impl) DialWithDialer(dialer *net.Dialer, network string, addr string, config *tls.Config) (*tls.Conn, error) {
	return tls.DialWithDialer(dialer, network, addr, config)
}
func (*Impl) InsecureCipherSuites() []*tls.CipherSuite {
	return tls.InsecureCipherSuites()
}
func (*Impl) Listen(network string, laddr string, config *tls.Config) (net.Listener, error) {
	return tls.Listen(network, laddr, config)
}
func (*Impl) LoadX509KeyPair(certFile string, keyFile string) (tls.Certificate, error) {
	return tls.LoadX509KeyPair(certFile, keyFile)
}
func (*Impl) NewLRUClientSessionCache(capacity int) tls.ClientSessionCache {
	return tls.NewLRUClientSessionCache(capacity)
}
func (*Impl) NewListener(inner net.Listener, config *tls.Config) net.Listener {
	return tls.NewListener(inner, config)
}
func (*Impl) Server(conn net.Conn, config *tls.Config) *tls.Conn {
	return tls.Server(conn, config)
}
func (*Impl) X509KeyPair(certPEMBlock []byte, keyPEMBlock []byte) (tls.Certificate, error) {
	return tls.X509KeyPair(certPEMBlock, keyPEMBlock)
}
