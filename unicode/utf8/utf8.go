// Code generated by a tool. DO NOT EDIT.

// Package utf8 provides a mockable wrapper for unicode/utf8.
package utf8

import (
	utf8 "unicode/utf8"
)

var _ Interface = &Impl{}
var _ = utf8.AppendRune

type Interface interface {
	AppendRune(p []byte, r rune) []byte
	DecodeLastRune(p []byte) (r rune, size int)
	DecodeLastRuneInString(s string) (r rune, size int)
	DecodeRune(p []byte) (r rune, size int)
	DecodeRuneInString(s string) (r rune, size int)
	EncodeRune(p []byte, r rune) int
	FullRune(p []byte) bool
	FullRuneInString(s string) bool
	RuneCount(p []byte) int
	RuneCountInString(s string) (n int)
	RuneLen(r rune) int
	RuneStart(b byte) bool
	Valid(p []byte) bool
	ValidRune(r rune) bool
	ValidString(s string) bool
}

type Impl struct{}

func (*Impl) AppendRune(p []byte, r rune) []byte {
	return utf8.AppendRune(p, r)
}
func (*Impl) DecodeLastRune(p []byte) (r rune, size int) {
	return utf8.DecodeLastRune(p)
}
func (*Impl) DecodeLastRuneInString(s string) (r rune, size int) {
	return utf8.DecodeLastRuneInString(s)
}
func (*Impl) DecodeRune(p []byte) (r rune, size int) {
	return utf8.DecodeRune(p)
}
func (*Impl) DecodeRuneInString(s string) (r rune, size int) {
	return utf8.DecodeRuneInString(s)
}
func (*Impl) EncodeRune(p []byte, r rune) int {
	return utf8.EncodeRune(p, r)
}
func (*Impl) FullRune(p []byte) bool {
	return utf8.FullRune(p)
}
func (*Impl) FullRuneInString(s string) bool {
	return utf8.FullRuneInString(s)
}
func (*Impl) RuneCount(p []byte) int {
	return utf8.RuneCount(p)
}
func (*Impl) RuneCountInString(s string) (n int) {
	return utf8.RuneCountInString(s)
}
func (*Impl) RuneLen(r rune) int {
	return utf8.RuneLen(r)
}
func (*Impl) RuneStart(b byte) bool {
	return utf8.RuneStart(b)
}
func (*Impl) Valid(p []byte) bool {
	return utf8.Valid(p)
}
func (*Impl) ValidRune(r rune) bool {
	return utf8.ValidRune(r)
}
func (*Impl) ValidString(s string) bool {
	return utf8.ValidString(s)
}
