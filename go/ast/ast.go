// Code generated by a tool. DO NOT EDIT.

// Package ast provides a mockable wrapper for go/ast.
package ast

import (
	ast "go/ast"
	token "go/token"
	io "io"
	reflect "reflect"
)

var _ Interface = &Impl{}
var _ = ast.FileExports

type Interface interface {
	FileExports(src *ast.File) bool
	FilterDecl(decl ast.Decl, f ast.Filter) bool
	FilterFile(src *ast.File, f ast.Filter) bool
	FilterPackage(pkg *ast.Package, f ast.Filter) bool
	Fprint(w io.Writer, fset *token.FileSet, x any, f ast.FieldFilter) error
	Inspect(node ast.Node, f func(ast.Node) bool)
	IsExported(name string) bool
	MergePackageFiles(pkg *ast.Package, mode ast.MergeMode) *ast.File
	NewCommentMap(fset *token.FileSet, node ast.Node, comments []*ast.CommentGroup) ast.CommentMap
	NewIdent(name string) *ast.Ident
	NewObj(kind ast.ObjKind, name string) *ast.Object
	NewPackage(fset *token.FileSet, files map[string]*ast.File, importer ast.Importer, universe *ast.Scope) (*ast.Package, error)
	NewScope(outer *ast.Scope) *ast.Scope
	NotNilFilter(_ string, v reflect.Value) bool
	PackageExports(pkg *ast.Package) bool
	Print(fset *token.FileSet, x any) error
	SortImports(fset *token.FileSet, f *ast.File)
	Walk(v ast.Visitor, node ast.Node)
}

type Impl struct{}

func (*Impl) FileExports(src *ast.File) bool {
	return ast.FileExports(src)
}
func (*Impl) FilterDecl(decl ast.Decl, f ast.Filter) bool {
	return ast.FilterDecl(decl, f)
}
func (*Impl) FilterFile(src *ast.File, f ast.Filter) bool {
	return ast.FilterFile(src, f)
}
func (*Impl) FilterPackage(pkg *ast.Package, f ast.Filter) bool {
	return ast.FilterPackage(pkg, f)
}
func (*Impl) Fprint(w io.Writer, fset *token.FileSet, x any, f ast.FieldFilter) error {
	return ast.Fprint(w, fset, x, f)
}
func (*Impl) Inspect(node ast.Node, f func(ast.Node) bool) {
	ast.Inspect(node, f)
}
func (*Impl) IsExported(name string) bool {
	return ast.IsExported(name)
}
func (*Impl) MergePackageFiles(pkg *ast.Package, mode ast.MergeMode) *ast.File {
	return ast.MergePackageFiles(pkg, mode)
}
func (*Impl) NewCommentMap(fset *token.FileSet, node ast.Node, comments []*ast.CommentGroup) ast.CommentMap {
	return ast.NewCommentMap(fset, node, comments)
}
func (*Impl) NewIdent(name string) *ast.Ident {
	return ast.NewIdent(name)
}
func (*Impl) NewObj(kind ast.ObjKind, name string) *ast.Object {
	return ast.NewObj(kind, name)
}
func (*Impl) NewPackage(fset *token.FileSet, files map[string]*ast.File, importer ast.Importer, universe *ast.Scope) (*ast.Package, error) {
	return ast.NewPackage(fset, files, importer, universe)
}
func (*Impl) NewScope(outer *ast.Scope) *ast.Scope {
	return ast.NewScope(outer)
}
func (*Impl) NotNilFilter(__v string, v_v reflect.Value) bool {
	return ast.NotNilFilter(__v, v_v)
}
func (*Impl) PackageExports(pkg *ast.Package) bool {
	return ast.PackageExports(pkg)
}
func (*Impl) Print(fset *token.FileSet, x any) error {
	return ast.Print(fset, x)
}
func (*Impl) SortImports(fset *token.FileSet, f *ast.File) {
	ast.SortImports(fset, f)
}
func (*Impl) Walk(v ast.Visitor, node ast.Node) {
	ast.Walk(v, node)
}
