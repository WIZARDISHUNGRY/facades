// Code generated by a tool. DO NOT EDIT.

// Package types provides a mockable wrapper for go/types.
package types

import (
	bytes "bytes"
	ast "go/ast"
	constant "go/constant"
	token "go/token"
	types "go/types"
)

var _ Interface = &Impl{}
var _ = types.AssertableTo

type Interface interface {
	AssertableTo(V *types.Interface, T types.Type) bool
	AssignableTo(V types.Type, T types.Type) bool
	CheckExpr(fset *token.FileSet, pkg *types.Package, pos token.Pos, expr ast.Expr, info *types.Info) (err error)
	Comparable(T types.Type) bool
	ConvertibleTo(V types.Type, T types.Type) bool
	DefPredeclaredTestFuncs()
	Default(t types.Type) types.Type
	Eval(fset *token.FileSet, pkg *types.Package, pos token.Pos, expr string) (_ types.TypeAndValue, err error)
	ExprString(x ast.Expr) string
	Id(pkg *types.Package, name string) string
	Identical(x types.Type, y types.Type) bool
	IdenticalIgnoreTags(x types.Type, y types.Type) bool
	Implements(V types.Type, T *types.Interface) bool
	Instantiate(ctxt *types.Context, orig types.Type, targs []types.Type, validate bool) (types.Type, error)
	IsInterface(t types.Type) bool
	LookupFieldOrMethod(T types.Type, addressable bool, pkg *types.Package, name string) (obj types.Object, index []int, indirect bool)
	MissingMethod(V types.Type, T *types.Interface, static bool) (method *types.Func, wrongType bool)
	NewArray(elem types.Type, len int64) *types.Array
	NewChan(dir types.ChanDir, elem types.Type) *types.Chan
	NewChecker(conf *types.Config, fset *token.FileSet, pkg *types.Package, info *types.Info) *types.Checker
	NewConst(pos token.Pos, pkg *types.Package, name string, typ types.Type, val constant.Value) *types.Const
	NewContext() *types.Context
	NewField(pos token.Pos, pkg *types.Package, name string, typ types.Type, embedded bool) *types.Var
	NewFunc(pos token.Pos, pkg *types.Package, name string, sig *types.Signature) *types.Func
	NewInterface(methods []*types.Func, embeddeds []*types.Named) *types.Interface
	NewInterfaceType(methods []*types.Func, embeddeds []types.Type) *types.Interface
	NewLabel(pos token.Pos, pkg *types.Package, name string) *types.Label
	NewMap(key types.Type, elem types.Type) *types.Map
	NewMethodSet(T types.Type) *types.MethodSet
	NewNamed(obj *types.TypeName, underlying types.Type, methods []*types.Func) *types.Named
	NewPackage(path string, name string) *types.Package
	NewParam(pos token.Pos, pkg *types.Package, name string, typ types.Type) *types.Var
	NewPkgName(pos token.Pos, pkg *types.Package, name string, imported *types.Package) *types.PkgName
	NewPointer(elem types.Type) *types.Pointer
	NewScope(parent *types.Scope, pos token.Pos, end token.Pos, comment string) *types.Scope
	NewSignature(recv *types.Var, params *types.Tuple, results *types.Tuple, variadic bool) *types.Signature
	NewSignatureType(recv *types.Var, recvTypeParams []*types.TypeParam, typeParams []*types.TypeParam, params *types.Tuple, results *types.Tuple, variadic bool) *types.Signature
	NewSlice(elem types.Type) *types.Slice
	NewStruct(fields []*types.Var, tags []string) *types.Struct
	NewTerm(tilde bool, typ types.Type) *types.Term
	NewTuple(x ...*types.Var) *types.Tuple
	NewTypeName(pos token.Pos, pkg *types.Package, name string, typ types.Type) *types.TypeName
	NewTypeParam(obj *types.TypeName, constraint types.Type) *types.TypeParam
	NewUnion(terms []*types.Term) *types.Union
	NewVar(pos token.Pos, pkg *types.Package, name string, typ types.Type) *types.Var
	ObjectString(obj types.Object, qf types.Qualifier) string
	RelativeTo(pkg *types.Package) types.Qualifier
	SelectionString(s *types.Selection, qf types.Qualifier) string
	SizesFor(compiler string, arch string) types.Sizes
	TypeString(typ types.Type, qf types.Qualifier) string
	WriteExpr(buf *bytes.Buffer, x ast.Expr)
	WriteSignature(buf *bytes.Buffer, sig *types.Signature, qf types.Qualifier)
	WriteType(buf *bytes.Buffer, typ types.Type, qf types.Qualifier)
}

type Impl struct{}

func (*Impl) AssertableTo(V *types.Interface, T types.Type) bool {
	return types.AssertableTo(V, T)
}
func (*Impl) AssignableTo(V types.Type, T types.Type) bool {
	return types.AssignableTo(V, T)
}
func (*Impl) CheckExpr(fset *token.FileSet, pkg *types.Package, pos token.Pos, expr ast.Expr, info *types.Info) (err error) {
	return types.CheckExpr(fset, pkg, pos, expr, info)
}
func (*Impl) Comparable(T types.Type) bool {
	return types.Comparable(T)
}
func (*Impl) ConvertibleTo(V types.Type, T types.Type) bool {
	return types.ConvertibleTo(V, T)
}
func (*Impl) DefPredeclaredTestFuncs() {
	types.DefPredeclaredTestFuncs()
}
func (*Impl) Default(t types.Type) types.Type {
	return types.Default(t)
}
func (*Impl) Eval(fset *token.FileSet, pkg *types.Package, pos token.Pos, expr string) (_ types.TypeAndValue, err error) {
	return types.Eval(fset, pkg, pos, expr)
}
func (*Impl) ExprString(x ast.Expr) string {
	return types.ExprString(x)
}
func (*Impl) Id(pkg *types.Package, name string) string {
	return types.Id(pkg, name)
}
func (*Impl) Identical(x types.Type, y types.Type) bool {
	return types.Identical(x, y)
}
func (*Impl) IdenticalIgnoreTags(x types.Type, y types.Type) bool {
	return types.IdenticalIgnoreTags(x, y)
}
func (*Impl) Implements(V types.Type, T *types.Interface) bool {
	return types.Implements(V, T)
}
func (*Impl) Instantiate(ctxt *types.Context, orig types.Type, targs []types.Type, validate bool) (types.Type, error) {
	return types.Instantiate(ctxt, orig, targs, validate)
}
func (*Impl) IsInterface(t types.Type) bool {
	return types.IsInterface(t)
}
func (*Impl) LookupFieldOrMethod(T types.Type, addressable bool, pkg *types.Package, name string) (obj types.Object, index []int, indirect bool) {
	return types.LookupFieldOrMethod(T, addressable, pkg, name)
}
func (*Impl) MissingMethod(V types.Type, T *types.Interface, static bool) (method *types.Func, wrongType bool) {
	return types.MissingMethod(V, T, static)
}
func (*Impl) NewArray(elem types.Type, len int64) *types.Array {
	return types.NewArray(elem, len)
}
func (*Impl) NewChan(dir types.ChanDir, elem types.Type) *types.Chan {
	return types.NewChan(dir, elem)
}
func (*Impl) NewChecker(conf *types.Config, fset *token.FileSet, pkg *types.Package, info *types.Info) *types.Checker {
	return types.NewChecker(conf, fset, pkg, info)
}
func (*Impl) NewConst(pos token.Pos, pkg *types.Package, name string, typ types.Type, val constant.Value) *types.Const {
	return types.NewConst(pos, pkg, name, typ, val)
}
func (*Impl) NewContext() *types.Context {
	return types.NewContext()
}
func (*Impl) NewField(pos token.Pos, pkg *types.Package, name string, typ types.Type, embedded bool) *types.Var {
	return types.NewField(pos, pkg, name, typ, embedded)
}
func (*Impl) NewFunc(pos token.Pos, pkg *types.Package, name string, sig *types.Signature) *types.Func {
	return types.NewFunc(pos, pkg, name, sig)
}
func (*Impl) NewInterface(methods []*types.Func, embeddeds []*types.Named) *types.Interface {
	return types.NewInterface(methods, embeddeds)
}
func (*Impl) NewInterfaceType(methods []*types.Func, embeddeds []types.Type) *types.Interface {
	return types.NewInterfaceType(methods, embeddeds)
}
func (*Impl) NewLabel(pos token.Pos, pkg *types.Package, name string) *types.Label {
	return types.NewLabel(pos, pkg, name)
}
func (*Impl) NewMap(key types.Type, elem types.Type) *types.Map {
	return types.NewMap(key, elem)
}
func (*Impl) NewMethodSet(T types.Type) *types.MethodSet {
	return types.NewMethodSet(T)
}
func (*Impl) NewNamed(obj *types.TypeName, underlying types.Type, methods []*types.Func) *types.Named {
	return types.NewNamed(obj, underlying, methods)
}
func (*Impl) NewPackage(path string, name string) *types.Package {
	return types.NewPackage(path, name)
}
func (*Impl) NewParam(pos token.Pos, pkg *types.Package, name string, typ types.Type) *types.Var {
	return types.NewParam(pos, pkg, name, typ)
}
func (*Impl) NewPkgName(pos token.Pos, pkg *types.Package, name string, imported *types.Package) *types.PkgName {
	return types.NewPkgName(pos, pkg, name, imported)
}
func (*Impl) NewPointer(elem types.Type) *types.Pointer {
	return types.NewPointer(elem)
}
func (*Impl) NewScope(parent *types.Scope, pos token.Pos, end token.Pos, comment string) *types.Scope {
	return types.NewScope(parent, pos, end, comment)
}
func (*Impl) NewSignature(recv *types.Var, params *types.Tuple, results *types.Tuple, variadic bool) *types.Signature {
	return types.NewSignature(recv, params, results, variadic)
}
func (*Impl) NewSignatureType(recv *types.Var, recvTypeParams []*types.TypeParam, typeParams []*types.TypeParam, params *types.Tuple, results *types.Tuple, variadic bool) *types.Signature {
	return types.NewSignatureType(recv, recvTypeParams, typeParams, params, results, variadic)
}
func (*Impl) NewSlice(elem types.Type) *types.Slice {
	return types.NewSlice(elem)
}
func (*Impl) NewStruct(fields []*types.Var, tags []string) *types.Struct {
	return types.NewStruct(fields, tags)
}
func (*Impl) NewTerm(tilde bool, typ types.Type) *types.Term {
	return types.NewTerm(tilde, typ)
}
func (*Impl) NewTuple(x ...*types.Var) *types.Tuple {
	return types.NewTuple(x...)
}
func (*Impl) NewTypeName(pos token.Pos, pkg *types.Package, name string, typ types.Type) *types.TypeName {
	return types.NewTypeName(pos, pkg, name, typ)
}
func (*Impl) NewTypeParam(obj *types.TypeName, constraint types.Type) *types.TypeParam {
	return types.NewTypeParam(obj, constraint)
}
func (*Impl) NewUnion(terms []*types.Term) *types.Union {
	return types.NewUnion(terms)
}
func (*Impl) NewVar(pos token.Pos, pkg *types.Package, name string, typ types.Type) *types.Var {
	return types.NewVar(pos, pkg, name, typ)
}
func (*Impl) ObjectString(obj types.Object, qf types.Qualifier) string {
	return types.ObjectString(obj, qf)
}
func (*Impl) RelativeTo(pkg *types.Package) types.Qualifier {
	return types.RelativeTo(pkg)
}
func (*Impl) SelectionString(s *types.Selection, qf types.Qualifier) string {
	return types.SelectionString(s, qf)
}
func (*Impl) SizesFor(compiler string, arch string) types.Sizes {
	return types.SizesFor(compiler, arch)
}
func (*Impl) TypeString(typ types.Type, qf types.Qualifier) string {
	return types.TypeString(typ, qf)
}
func (*Impl) WriteExpr(buf *bytes.Buffer, x ast.Expr) {
	types.WriteExpr(buf, x)
}
func (*Impl) WriteSignature(buf *bytes.Buffer, sig *types.Signature, qf types.Qualifier) {
	types.WriteSignature(buf, sig, qf)
}
func (*Impl) WriteType(buf *bytes.Buffer, typ types.Type, qf types.Qualifier) {
	types.WriteType(buf, typ, qf)
}
