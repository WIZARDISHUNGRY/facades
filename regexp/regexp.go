// Code generated by a tool. DO NOT EDIT.

// Package regexp provides a mockable wrapper for regexp.
package regexp

import (
	io "io"
	regexp "regexp"
)

var _ Interface = &Impl{}
var _ = regexp.Compile

type Interface interface {
	Compile(expr string) (*regexp.Regexp, error)
	CompilePOSIX(expr string) (*regexp.Regexp, error)
	Match(pattern string, b []byte) (matched bool, err error)
	MatchReader(pattern string, r io.RuneReader) (matched bool, err error)
	MatchString(pattern string, s string) (matched bool, err error)
	MustCompile(str string) *regexp.Regexp
	MustCompilePOSIX(str string) *regexp.Regexp
	QuoteMeta(s string) string
}

type Impl struct{}

func (*Impl) Compile(expr string) (*regexp.Regexp, error) {
	return regexp.Compile(expr)
}
func (*Impl) CompilePOSIX(expr string) (*regexp.Regexp, error) {
	return regexp.CompilePOSIX(expr)
}
func (*Impl) Match(pattern string, b []byte) (matched bool, err error) {
	return regexp.Match(pattern, b)
}
func (*Impl) MatchReader(pattern string, r io.RuneReader) (matched bool, err error) {
	return regexp.MatchReader(pattern, r)
}
func (*Impl) MatchString(pattern string, s string) (matched bool, err error) {
	return regexp.MatchString(pattern, s)
}
func (*Impl) MustCompile(str string) *regexp.Regexp {
	return regexp.MustCompile(str)
}
func (*Impl) MustCompilePOSIX(str string) *regexp.Regexp {
	return regexp.MustCompilePOSIX(str)
}
func (*Impl) QuoteMeta(s string) string {
	return regexp.QuoteMeta(s)
}
